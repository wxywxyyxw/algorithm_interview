__author__ = 'wangxiaoyang'
"""
排序（上）：为什么插入排序比冒泡排序更受欢迎？

如何分析一个“排序算法”？

排序算法的执行效率
1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数 、低阶
3. 比较次数和交换（或移动）次数

排序算法的内存消耗
算法的内存消耗可以通过空间复杂度来衡量
原地排序算法，就是特指空间复杂度是 O(1) 的排序算法

排序算法的稳定性
稳定性是指: 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

冒泡排序（Bubble Sort）
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法
冒泡排序是稳定的排序算法
时间复杂度:最好情况时间复杂度是 O(n),最坏情况时间复杂度为 O(n2) 平均情况下的时间复杂度就是 O(n2)

插入排序（Insertion Sort）
首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。
插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
重复这个过程，直到未排序区间中元素为空，算法结束
这是一个原地排序算法
插入排序是稳定的排序算法
时间复杂度:最好情况时间复杂度是 O(n),最坏情况时间复杂度为 O(n2) 平均情况下的时间复杂度就是 O(n2)

选择排序（Selection Sort）
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)
选择排序是一种不稳定的排序算法

冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个

"""
